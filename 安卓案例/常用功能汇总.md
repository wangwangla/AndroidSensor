# 安卓

​	java安卓的view可以使用xml，也可以使用java代码，也可以使用java和xml一起进行，view的理解，view就相当于一个窗子的每一个玻璃，窗框就相当于每一个格子。

​	布局之后的下一个使用布局对页面进行设置，比如有线性布局，相对布局，以及帧布局，当然也可以自己定义一个view做一个特定的显示，显示的位置以及显示的属性进行设置。

## 自定义view

xml页面引入Fragment

```
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="test.kw.androiddemo.MainActivity">
    <FrameLayout android:layout_width="wrap_content"
                 android:id="@+id/fl"
                 android:layout_height="wrap_content">
    </FrameLayout>
</android.support.constraint.ConstraintLayout>
```

编写view

```
public class MyView extends View {
    float X;
    float Y;

    public MyView(Context context) {
        super(context);
        X = 200;
        Y = 200;
    }

    //设置显示位置
    @Override
    protected void onDraw(Canvas canvas) {
        // TODO Auto-generated method stub
        super.onDraw(canvas);
        Paint paint = new Paint();
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_background);
        canvas.drawBitmap(bitmap, X, Y, paint);
        if (bitmap.isRecycled()) {
            bitmap.recycle();
        }
    }
}
```

显是view

```
/**
 * 自创view,并显示
 * 步骤：
 *  （1）显=页面引入FragLayout
 *  (2)书写view
 *  （3）引入view并显示
 *
 */
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        FrameLayout frameLayout = findViewById(R.id.fl);
        final MyView myView = new MyView(MainActivity.this);
        myView.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent motionEvent) {
                myView.X=motionEvent.getX();
                myView.Y=motionEvent.getY();
                //重新绘制
                myView.invalidate();
                return true;
            }
        });
        frameLayout.addView(myView);
    }
}

```

##  布局

#### 线性布局

```
线性布局有水平和竖直两种，如果超出将不会进行显示，可以执行水平居中和竖直居中，可以设置长和宽等
```

绝对布局

```
确定一个布局，然后通过指定其左右上下进行确定下一个view的位置
```

帧布局

```
一个布局可以在一个不就的上面，比如一个图片上的一个一个图片，这种可以使用帧布局，也可以使用绝对布局的方式完成
```

表格布局

```
他可以跨行进行显示，但是不可以跨列进行显示
```

网格布局

```
既可以跨行，也可以跨列进行显示
```

布局管理器的嵌套

```

```

### 基本组件

文本框

```

```

编辑框

```

```

按钮

```
可以使用文字，也可以使用图片作为按钮
	<Button 
	    android:layout_height="wrap_content"
	    android:layout_width="match_parent"
	    android:text="XXX"/>
	<!-- 按钮背景可以使用图片，也可以使用形状 -->
	<ImageButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:background="#0000"
	    android:src="@drawable/ic_launcher"/>
```

图片按钮

```

```

单选按钮

```
单选框
	<RadioGroup android:layout_height="wrap_content"
	    android:id="@+id/radios"
	    android:layout_width="wrap_content">
	    	<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:checked="true"
	    android:text="男"/>
		<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:text="女"/>
	</RadioGroup>
	<Button 
	    android:id="@+id/XXX"
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="提交"/>

```

检测其状态

```
final RadioGroup radioGroup = (RadioGroup)findViewById(R.id.radios);
//方式一：
radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
		@Override
		public void onCheckedChanged(RadioGroup group, int checkedId) {
			// TODO Auto-generated method stub
			RadioButton r = (RadioButton)findViewById(checkedId);
			//获取参数
			r.getText();
		 }
});
```

检测方式二：使用按钮

```
findViewById(R.id.XXX).setOnClickListener(new View.OnClickListener() {
       @Override
	   public void onClick(View v) {
		    // TODO Auto-generated method stub
			//循环
			for(int i=0;i<radioGroup.getChildCount();i++) {
				RadioButton radioButton = (RadioButton)radioGroup.getChildAt(i);
				if(radioButton.isChecked()) {
					radioButton.getText();
			  	    //单选只有一个可以选中，这个时候就可以跳出
					break;
				}
			}
		}
});
```

键盘按键按下和弹起

```
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		Toast.makeText(MainActivity.this, "触摸", Toast.LENGTH_SHORT).show();
		return super.onTouchEvent(event);
	}
	
	
    @Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if(keyCode==KeyEvent.KEYCODE_BACK) {
			exit();
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
	
	
	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) {
		return super.onKeyUp(keyCode, event);
	}
	
	
	public void exit() {
		if((System.currentTimeMillis()-exitLong)>=2000) {
			Toast.makeText(MainActivity.this, "再按一次退出", Toast.LENGTH_SHORT).show();
			exitLong = System.currentTimeMillis();
		}else {
			finish();
			System.exit(0);
		}
```

Fragment的创建和使用

```
页面
F1
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#445533"
    android:orientation="vertical" >
    <TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Detail"/>

</LinearLayout>


F2
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:background="#550000"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    
	<TextView 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="XXXXXXXXXX"/>
</LinearLayout>


java中的代码
public class DetailFragment extends Fragment {
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		return inflater.inflate(R.layout.activity_detail_fragment, null);
	}
}


在xml中使用
	<fragment 
	    android:layout_width="wrap_content"
	    android:layout_height="match_parent"
	    android:name="com.example.listfragment.MyFragment"
	    android:id="@+id/list"
	    android:layout_weight="1"/>
	<fragment 
	    android:layout_width="wrap_content"
	    android:layout_height="match_parent"
	    android:name="com.example.listfragment.DetailFragment"
	    android:id="@+id/detail"
	    android:background="#333333"
	    android:layout_weight="2"/> -->
	    
	    
在java代码中使用
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		DetailFragment detailFragment = new DetailFragment();
		
		FragmentTransaction transaction = getFragmentManager().beginTransaction();
		transaction.add(R.id.fl, detailFragment);
		transaction.commit();
	}
}

```



复选框

```
复选框

	<CheckBox 
	    android:id="@+id/ch1"
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
	<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
		<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
		<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
			<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
```

复选框的选中

```
		final CheckBox checkBox = (CheckBox) findViewById(R.id.ch1);
		checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				// TODO Auto-generated method stub
				if(checkBox.isChecked()) {
					checkBox.getText();
				}
			}
		});
		
```



日期

```

```

时间

```

```

计时器

```

```

进度条

```

```

拖动条

```

```

星级条

```

```

图像视图

```

```

触摸

长按按钮，出现菜单项

```
    <Button 
        android:id="@+id/btn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="XXXXX"/>
```

长按检测

```
		Button button = (Button)findViewById(R.id.btn);
		button.setOnLongClickListener(new View.OnLongClickListener() {
			
			@Override
			public boolean onLongClick(View v) {
				// TODO Auto-generated method stub
				registerForContextMenu(v);
				openContextMenu(v);
				return false;
			}
		});
```

创建菜单

```
	public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
		// TODO Auto-generated method stub
		super.onCreateContextMenu(menu, v, menuInfo);
		menu.add("XXXXXX");
		menu.add("XXeee");
	}
```

触摸检测

````
		final ChumoView chumoView = new ChumoView(MainActivity.this);
		//给它加上一个事件监听器
		chumoView.setOnTouchListener(new View.OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				// TODO Auto-generated method stub
				chumoView.X = event.getX()-80;
				chumoView.Y = event.getY()-80;
				chumoView.invalidate();
				if(event.getAction() == MotionEvent.ACTION_DOWN) {
					///按键按下
				}else if(event.getAction() == MotionEvent.ACTION_UP) {
					//按键弹起
				}
				return true;
			}
		});
````

日期：

```
	<DatePicker 
	    android:id="@+id/data"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    />
```



闹钟

```
    <TimePicker android:layout_width="wrap_content"
                android:id="@+id/time"
                android:layout_height="wrap_content"></TimePicker>
    <Button android:layout_width="wrap_content"
            android:text="选中时间"
            android:id="@+id/btn"
            android:layout_height="wrap_content"/>
```

java代码实现逻辑

```
               Intent intent = new Intent(MainActivity.this,AlarmActivity.class);
                PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this,0,intent,0);
                AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
                Calendar c = Calendar.getInstance();
                c.set(Calendar.HOUR_OF_DAY,timePicker.getCurrentHour());
                c.set(Calendar.MINUTE,timePicker.getCurrentMinute());
                c.set(Calendar.SECOND,0);
                //ELAPSED_REALTIME多久之后提醒
                //ELAPSED_REALTIME_WAKEUP 可以唤醒系统
                //RTC指定时间提醒
                //RTC_WAKEUP
                alarmManager.set(AlarmManager.RTC_WAKEUP,c.getTimeInMillis(),pendingIntent);
```

四种弹出框

```
        setContentView(R.layout.activity_dialog);
        findViewById(R.id.btn1).setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {

                AlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();
                alertDialog.setIcon(R.drawable.ic_launcher_background);
                alertDialog.setTitle("XXX");
                alertDialog.setMessage("XXXXXXXXXXXXXXXXXXX");
                alertDialog.setButton(DialogInterface.BUTTON_NEGATIVE, "fu", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        Toast.makeText(MainActivity.this,"XX",Toast.LENGTH_LONG).show();
                    }
                });
                alertDialog.setButton(DialogInterface.BUTTON_POSITIVE, "fu", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        Toast.makeText(MainActivity.this,"XX",Toast.LENGTH_LONG).show();
                    }
                });
                alertDialog.show();
            }
        });
        findViewById(R.id.btn2).setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {
                final String []arr = {"XXXXXX","CCCC","SSS","EEE"};

                AlertDialog.Builder builder =  new AlertDialog.Builder(MainActivity.this);
                builder.setIcon(R.drawable.ic_launcher_background);
                builder.setTitle("XXXX");
                builder.setItems(arr, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        Toast.makeText(MainActivity.this,arr[i],Toast.LENGTH_LONG).show();
                    }
                });
                //创建对话框，并显示
                builder.create().show();
            }
        });
        findViewById(R.id.btn3).setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {
                final String []arr = {"XXXXXX","CCCC","SSS","EEE"};

                AlertDialog.Builder builder =  new AlertDialog.Builder(MainActivity.this);
                builder.setIcon(R.drawable.ic_launcher_background);
                builder.setTitle("XXXX");
                builder.setSingleChoiceItems(arr, 0, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        Toast.makeText(MainActivity.this,arr[i],Toast.LENGTH_LONG).show();
                    }
                });
                builder.setPositiveButton("确定",null);
                builder.create();
                //创建对话框，并显示
                builder.create().show();
            }
        });
        findViewById(R.id.btn4).setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {
                final String []arr = {"XXXXXX","CCCC","SSS","EEE"};
                final boolean []arr1 = {true,false,true,true};

                AlertDialog.Builder builder =  new AlertDialog.Builder(MainActivity.this);
                builder.setIcon(R.drawable.ic_launcher_background);
                builder.setTitle("XXXX");
                builder.setMultiChoiceItems(arr, arr1, new DialogInterface.OnMultiChoiceClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i, boolean b) {
                        arr1[i]=b;
                    }
                });
                builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int j) {
                        String re = null;
                        for (int i=0;i<arr1.length;i++){
                            if(arr1[i]){
                                re+=arr[i]+"、";
                            }
                        }
                        if(re!=null){
                            Toast.makeText(MainActivity.this,re,Toast.LENGTH_LONG).show();
                        }
                    }
                });

                builder.create().show();
            }
        });
```

通知栏

```
  protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_nitiification);

        NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        Notification.Builder notification = new Notification.Builder(NitiificationActivity.this);
        notification.setAutoCancel(true);
        notification.setSmallIcon(R.drawable.ic_launcher_background);
        notification.setContentTitle("XXXXXXXXXXXXX");
        notification.setContentText("cccccccc");
        notification.setWhen(System.currentTimeMillis());
        notification.setDefaults(Notification.DEFAULT_SOUND|Notification.DEFAULT_VIBRATE);
        Intent intent = new Intent(NitiificationActivity.this,MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(NitiificationActivity.this,0,intent,0);
        notification.setContentIntent(pi);
        notificationManager.notify(NOTIFICATIONID,notification.build());
    }
}
```

画笔使用

```
Main

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        FrameLayout frameLayout = findViewById(R.id.c_fl);
        frameLayout.addView(new MyViewguiji(this));
    }
}

```

定义View

```
public class MyView extends View {
    public MyView(Context context) {
        super(context);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //画笔
        Paint paint = new Paint();
        //设置颜色     默认情况下，安卓默认是透明的
        paint.setColor(0xFFFF6600);
        //填充方式
        paint.setStyle(Paint.Style.FILL);
        //设置画图范围
        canvas.drawRect(29,12,100,100,paint);
    }
}

-------------------------------------------
public class myView01 extends View {
    public myView01(Context context) {
        super(context);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //绘制机器人
        //创建画笔
        Paint paint = new Paint();//创建一个画笔
        paint.setAntiAlias(true);//抗锯齿
        paint.setColor(0xFFA4C739);
        //绘制头
        /**
         * 第一个参数  外轮廓矩形区域   控制大小
         * 第二个参数  起始角度
         * 第三个参数  扫过的角度
         * 第四个参数  是否包括圆心在内
         * 第五个参数  画笔
         *
         */
        RectF rectF = new RectF(10,10,100,100);
      //  rectF.offset(90,20);//头位置
        //rectF   起始角度
        canvas.drawArc(rectF,0,-180,false,paint);
    }
}



-----------------------------
 */
public class MyViewBit extends View {

    public MyViewBit(Context context) {
        super(context);
    }
    /**
     * 通过两种方法进行创建位图
     */
    /**
     *  BitmapFactory
     *  - 通过图片文件创建
     *  - 通过输入流创建
     *  创建
     *  - decodeFile()   通过连接创建
     *  - decodeResource（）  通过创建资源ID来创建
     *  - decodeStream（）   通过输入流进行创建
     *  Bitmap
     *  - 挖去一小块创建
     *  - 将原位图缩放生成
     *  - 颜色数组创建
     */

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //访问外存，一定要给权限
        String path = Environment.getExternalStorageDirectory()+"/1.jpg";
        Bitmap bitmap = BitmapFactory.decodeFile(path);
        Paint paint = new Paint();
        //画图片   绘制图，指定位置
        canvas.drawBitmap(bitmap,0,0,paint);
    /*************************上面绘制整个图片***********************************/

        //挖取一小块
        Bitmap bitmap1 = Bitmap.createBitmap(bitmap,34,45,100,100);
        canvas.drawBitmap(bitmap1,389,23,paint);
    }
    
    =================================
    public class MyViewguiji extends View {
    public MyViewguiji(Context context) {
        super(context);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setColor(0xFF0000FF);
        paint.setStyle(Paint.Style.STROKE);//设置样式   描边


        //绘制路径
        Path path = new Path();
        //圆心  半径  绘制顺时针还是逆时针
        path.addCircle(150,150,50,Path.Direction.CW);//ccw逆时针   cw顺时针

        //绘制路径
        canvas.drawPath(path,paint);
        //或者使用
        //文本    路径  水平偏移量   竖直偏移量  画笔
        paint.setTextSize(30);
        canvas.drawTextOnPath("我是啦啦啦",path,0,0,paint);
    }
}
-----------------------------
public class MyViewText extends View {

    public MyViewText(Context context) {
        super(context);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        Paint paint = new Paint();
        paint.setColor(0xFF000000);
        paint.setAntiAlias(true);
        paint.setTextAlign(Paint.Align.LEFT);
        paint.setTextSize(12);

        canvas.drawText("XXX",20,20,paint);
    }
    -------------------------------
```



广播

```
    <Button android:layout_width="wrap_content"
            android:id="@+id/btncard"
            android:text="发送广播"
            android:layout_height="wrap_content"/>
```

发送广播

```
Intent intent = new Intent();
intent.setAction("asdf");
sendBroadcast(intent);



XML

   <!--是否被实例化
        能否接受其他应用程序非常的广播
        -->
        <receiver android:name=".Recevicer"
            android:enabled="true"
                  android:exported="true"
        >
            <intent-filter>
                <action android:name="asdf"></action>
                <action android:name="maz"></action>
            </intent-filter>

        </receiver>
```

接受广播

```
    @Override
    public void onReceive(Context context, Intent intent) {
        if(intent.getAction().equals("asdf")){
            Toast.makeText(context,"XXXXXXXX",Toast.LENGTH_SHORT).show();
        }else if(intent.getAction().equals("XX")){
            Toast.makeText(context,"UUUUUUUUUU",Toast.LENGTH_SHORT).show();
        }
    }
}
```

HandLer

```
    /**
     * 安卓中，不允许子线程更改主线程
     * 如果需要更新，就需要使用handler
     *
     * 它的执行，基本就是先发出一个消息，然后Handler对消息进行处理
     *
     * 接收消息，会对消息进行判断
     *
     * 在任意线程中进行执行操作，他基本就是在子线程中发出消息，在主线程中获取消息，让在Handler中进行处理
     * @param savedInstanceState
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```

Handler案例

```

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final TextView textView = findViewById(R.id.textview);
        Button button = findViewById(R.id.btn);
        final Handler handler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if(msg.what==0x123){
                    textView.setText("XXXXXXXXXXXXXXXXXXX");
                }
            }
        };
        /*处理消息*/
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                new Thread(
                        new Runnable() {
                            @Override
                            public void run() {
                            /**
                             *  textView.setText("XXX");
                             *  子线程是不可以修改主线程的
                             *
                             *
                             *  */
                            //发送消息
                            handler.sendEmptyMessage(0x123);
                            }
                        }
                ).start();
            }
        });
    }
}

```



Handler更新进度条

```
public class HandlerActivity extends AppCompatActivity {
    private  int Time = 60;
    private int Time_Msg = 0x001;
    private int mProgressStatus = 0;
    private ProgressBar process;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_han);
         process = findViewById(R.id.pro);
        handler.sendEmptyMessage(Time_Msg);
    }
    //创建Handler一秒更新一次
    Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if (Time-mProgressStatus>0){
                mProgressStatus++;
                process.setProgress(mProgressStatus);
                handler.sendEmptyMessageDelayed(Time_Msg,1000);
            }else {
                Toast.makeText(HandlerActivity.this,"完成",Toast.LENGTH_SHORT).show();
            }
        }
    };
}

```

创建Looper

````

/**
 * auther   kangwang
 *
 *  Looper：他是一个循环器，存储消息的管理器，一个线程对应一个Looper对象，一个Looper对应一个MessageQueue，
 *  Handler首先获取一个Message，然后通过handler将消息发送给Looper ，looper又会将消息按顺序的发生给handler
 *
 *
 *
 *
 *  Message是存放数据的，携带数据，存放整形数据  任意对象  发送到哪里  自定义的消息代码
 *  创建message对象，  message.obtain()   handler.obtainMessage
 *
 *
 *
 *  Looper创建
 *      主线程中创建的是时候，会自动的创建一个Looper,如果在子线程中，将如何处理
 */
public class LooperThread extends Thread {
    private Handler handler ;

    @Override
    public void run() {
        super.run();
        //启动Looper
        Looper.prepare();
        //shilihua
        handler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
            }
        };
        //创建message对象 发送消息
        Message message = handler.obtainMessage();
        //设置代码
        message.what=0x33;
        //发送消息
        handler.sendMessage(message);
        //启动Looper
        Looper.loop();
    }
}
````

Service

```
public class MainActivity extends AppCompatActivity {

    /**
     * service可以在后台长时间运行的，并且没哟用户界面的程序组件。
     *
     * 可以在后台下载文件等一些操作  后台播放歌曲
     *
     * service分类：
     *  Start Service和Bound Service
     *  Start Service：使用Start Service开启的service的方法，开始的时候service并没有启动，只有在Activity中调用的时候，才可以启动service
     *  没有相互交互
     *
     *  BoundService：使用BoundService的Service方法，运行的时候Service和Activity就绑定在一起了
     *
     *
     *
     *  Activity页面关闭，他也就关闭了。
     *
     *
     *  创建和配置Service  一种是启动和停止service
     *
     *
     * @param savedInstanceState
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}



MyService 
public class MyService extends Service {
    public MyService() {
    }

    //service必须实现的方法
    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        throw new UnsupportedOperationException("Not yet implemented");
    }
    //创建是调用
    @Override
    public void onCreate() {
        super.onCreate();
    }
    //开始service的时候调用
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }
    //销毁的时候调用
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
    //判断service是否在运行
    public boolean isRunning(){
        ActivityManager activityManager =(ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        ArrayList<ActivityManager.RunningServiceInfo> activityManagers =
    }
}
```



Activity

```

```

Bundle传递数据

```

```

Intent返回参数

```
一个Intent跳转  让它完成一个任务，之后将结果返回
Intent intent = new Intent(MainActivity.this,SeconedActivity.class);
startActivityForResult(intent, 0x11);
```

在第二个里面， 将参数放入Bundle中

```
Intent intent = getIntent();
Bundle bundle = new Bundle();		
bundle.putString("XX", "XXX");
intent.putExtras(bundle);
setResult(0x11, intent);
finish();
```

在前一个Activity中接收参数

```
@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		// TODO Auto-generated method stub
		super.onActivityResult(requestCode, resultCode, data);
		if(requestCode==0x11&&resultCode==0x11) {
			Bundle bundle = data.getExtras();
			String da = bundle.getString("XX");
			textView.setText(da);
		}
```

Intent拦截器

```
Intent intent = new Intent();
intent.setAction(intent.ACTION_VIEW);
startActivity(intent);
```

定义一个页面跳转，在配置文件中顶一个一个拦截器

```
<activity
    android:name=".ShowActivity"
    android:label="@string/title_activity_show" >
      <intent-filter>
           <action android:name="android.intent.action.VIEW"/>
           <category android:name="android.intent.category.DEFAULT">
           </category>          
        </intent-filter>
 </activity>
```



Fragment

```

```

Intent

```

```

ComponentName

```

```

Action  Data

```

```

Action和category

```

```

Extras flags

```

```

Intent种类

```

```

Intent过滤器

```

```



AlertDialog的使用

```
创建实例
设置图标
设置标题
设置内容
设置按钮



```

## 资源

#####  数组

在values目录下创建arrays.xml

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string-array name="liststring">
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	</string-array>    
</resources>
```

xml使用

```
	<ListView 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:entries="@array/liststring">
	</ListView>
```

在java程序中使用

```
String []arr =getResources().getStringArray(R.array.liststring);
```

##### 颜色

values目录下colors.xml

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#3F51B5</color>
    <color name="colorPrimaryDark">#303F9F</color>
    <color name="colorAccent">#FF4081</color>
</resources>
```

#### 字符串

strings.xml

```
<resources>
    <string name="app_name">My Application</string>
</resources>
```

### 样式

```
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>
</resources>
```

样式可以在所以的布局上，也可以在一个页面上





 android:gravity="left|bottom"设置它内部的组件位置  可以指定一个参数，也可以使用两个参数

layout_weight:占用剩余空间，



登录页面，作用的账号和密码，可以使用drawableLeft

前景图和前景图的位置：前景图不会被覆盖掉，foreground    foregroundgravity

可以是一张图片，位置可以使用     right|bottom





表格布局

```
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="com.example.androidtable.MainActivity" >

    <TableRow >
        <Button 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="XXX"/>
         <Button 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="XXX"/>       
         <Button 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="XXX"/>       
         <Button 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="XXX"/>
    </TableRow>
</TableLayout>
```



可以设置那些列被隐藏，那些列被拉伸，假如第二列被隐藏，那么就设置参数为1

 android:collapseColumns="1"

 android:stretchColumns="3"那一列被拉伸

如果内容太大无法显示的时候，收缩就是收缩某一列的宽度，让内容进行显示

android:shrinkColumns="2"



## 网格布局管理器

网格可以跨行，可以跨列

可以设置一行显示几个，一列显示几个columnCount(列个数)

排列形式：orientation=“” v h



```
layout_column:位置第几列的
layout_columnSpan:横向跨几列
layout_columnWeight:横向的权重
layout_grary:怎样占据子组件的
layout_row:位置第几hang的
layout_rowSpan:横向跨几hang 
```





## 基本组件

输入框：			

```
android:ems="14" 宽度
android:singleLine="true"单行
android:lines="6"多行
```

拉伸整个屏幕：scaleType="fitXY"



单选按钮

```
	<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:text="男"/>
```

text：添加文本    checked:true  选中

单选组

```
	<RadioGroup  android:layout_height="wrap_content"
	    android:layout_width="wrap_content">
		<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:checked="true"
	    android:text="男"/>
		<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:checked="true"
	    android:text="女"/>
	</RadioGroup>
```

我们要为一个按钮组添加一个事件监听器，我们需要对他们加上一个ID

方式一：

```
		//方式一：
		radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
			
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				// TODO Auto-generated method stub
				RadioButton r = (RadioButton)findViewById(checkedId);
				//获取参数
				r.getText();
				
			}
		});
```

```
<RadioGroup android:layout_height="wrap_content"
	    android:id="@+id/radios"
	    android:layout_width="wrap_content">
	    	<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:checked="true"
	    android:text="男"/>
		<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:text="女"/>
	</RadioGroup>
```

方式二：

```
	<RadioGroup android:layout_height="wrap_content"
	    android:id="@+id/radios"
	    android:layout_width="wrap_content">
	    	<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:checked="true"
	    android:text="男"/>
		<RadioButton 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:text="女"/>
	</RadioGroup>
	<Button 
	    android:id="@+id/XXX"
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="提交"/>
```

```
		findViewById(R.id.XXX).setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				//循环
				for(int i=0;i<radioGroup.getChildCount();i++) {
					RadioButton radioButton = (RadioButton)radioGroup.getChildAt(i);
					if(radioButton.isChecked()) {
						radioButton.getText();
						//单选只有一个可以选中，这个时候就可以跳出
						break;
					}
				}
			}
		});
```

## 复选框

```
<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
	<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
		<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
		<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
			<CheckBox 
	    android:layout_width="wrap_content"
	    android:text="显示密码"
	    android:layout_height="wrap_content">
	    
	</CheckBox>
```

```
为了可以监听，我们需要加入一个ID属性
final CheckBox checkBox = (CheckBox) findViewById(R.id.ch1);
		checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				// TODO Auto-generated method stub
				if(checkBox.isChecked()) {
					checkBox.getText();
				}
			}
		});
```

## 日期选择器

```

	<DatePicker 
	    android:id="@+id/data"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    
	    />
```

添加事件：获取日期组件  获取年份 月 日

给组件进行初始化，年月日设置，然后在加入一个监听器

```
    DatePicker datePicker;
    int year ;
    int month;
    int da;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        datePicker = findViewById(R.id.datepi);
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH);
        final int da = calendar.get(Calendar.YEAR);
        datePicker.init(year, month, da, new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker datePicker, int year, int month, int day) {
                DatePaAcitivty.this.year = year;
                DatePaAcitivty.this.month = month;
                DatePaAcitivty.this.da = day;
            }
        });
```

## 时间选择

```
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
        <TimePicker android:layout_width="wrap_content"
                    android:id="@+id/timepa"
                    android:layout_height="wrap_content">

        </TimePicker>
</LinearLayout>

```

```
  protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        timePicker = findViewById(R.id.timepa);
        //时间监听器
        timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
            @Override
            public void onTimeChanged(TimePicker timePicker, int hour, int minutes) {
                String str = hour+"shi";

            }
        });
```

## 计时器

```
<Chronometer android:layout_width="wrap_content"
		  android:layout_height="wrap_content"/>
<Chronometer android:layout_width="wrap_content"
          android:format="使用时间：%s"
          android:layout_height="wrap_content"/>
```

方法

setBase():开始计时              setFormat：设置时间格式

setStart(): 指定开始时间      stop():停止

setOnChronometerTickListener():添加事件的

```
        chronometer = findViewById(R.id.chronometeri);
        chronometer.setBase(SystemClock.elapsedRealtime());
        chronometer.setFormat("%s");
        chronometer.start();
        chronometer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() {
            @Override
            public void onChronometerTick(Chronometer chronometer) {
                if(SystemClock.elapsedRealtime()-chronometer.getBase()>=60){
                    chronometer.stop();
                }
            }
        });
```

## 进度条

```
<ProgressBar android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
```

样式设置，默认是原型的，也可以是其他的



通过style进行设置

- 主题方式
- 安装自带样式

```
<ProgressBar android:layout_width="match_parent"
             style="?android:attr/progressBarStyleHorizontal"
             android:layout_height="wrap_content"/>
```

设置进度条属性

- 最大进度的
- 当前进度

```
    <ProgressBar android:layout_width="wrap_content"
                 android:layout_height="wrap_content"/>

    <ProgressBar android:layout_width="match_parent"
                 style="?android:attr/progressBarStyleHorizontal"
                 android:background="#fff"
                 android:max="100"
                 android:progress="40"
                 android:layout_height="wrap_content"/>
```

进度条的改变，可以通过线程来改变setProgress更新进度

setVisibillity（）设置是否显示

案例“

````
    <ProgressBar android:layout_width="match_parent"
                 android:id="@+id/progress"
                 style="?android:attr/progressBarStyleHorizontal"
                 android:background="#fff"
                 android:max="100"
                 android:progress="40"
                 android:layout_height="wrap_content"/>
````

activity程序

```
public class ProgressActivity extends Activity {
    private Handler mHandler;
    private int mProgress;
    private ProgressBar progressBar;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_progess);
        progressBar = findViewById(R.id.progress);
        mHandler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                if(msg.what==0x111){
                    progressBar.setProgress(mProgress);
                }else {
                    /*不显示*/
                    progressBar.setVisibility(View.GONE);
                }
            }
        };
        //创建线程
        new Thread(new Runnable(){
            @Override
            public void run() {
                while (true) {
                    mProgress = dowork();
                    Message message = new Message();
                    if (mProgress < 100) {
                        message.what = 0x11;
                        mHandler.sendMessage(message);
                    } else {
                        message.what = 0x110;
                        mHandler.sendMessage(message);
                        break;
                    }
                }
            }
            private  int dowork(){
                mProgress+=Math.random()*10;
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return mProgress;
            }
        }).start();
    }

```

## 拖动条

```
    <SeekBar android:layout_width="match_parent" 
    		android:layout_height="wrap_content"/>
```

设置最大值和当前值

```
    <SeekBar android:layout_width="match_parent"
             android:max="100"
             android:progress="50"
             android:layout_height="wrap_content"/>
```

设置拖动条的图片

```
    <SeekBar android:layout_width="match_parent"
             android:max="100"
             android:progress="50"
             android:thumb="@drawable/ic_launcher_background"
             android:layout_height="wrap_content"/>
```

拖动条事件监听器

```
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_seek_bar);
        android.widget.SeekBar seekBar = findViewById(R.id.seekba);
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            /*进度改变时执行的方法*/
            @Override
            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {
                
            }
            /*开始触摸时的方法*/
            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }
            /*停止触摸时的方法*/
            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {

            }
        });
    }
}
```

## 星级条

```
星级条
    <RatingBar android:layout_width="wrap_content"
               android:layout_height="wrap_content"/>
```

星星的个数

```
    <RatingBar android:layout_width="wrap_content"
               android:numStars="8"
               android:layout_height="wrap_content"/>
```

点亮星星

```
    <RatingBar android:layout_width="wrap_content"
               android:numStars="8"
               android:rating="4"
               android:layout_height="wrap_content"/>
```

只可以一整颗一整颗的显示

```
    <RatingBar android:layout_width="wrap_content"
               android:numStars="8"
               android:rating="4"
               android:stepSize="1"
               android:layout_height="wrap_content"/>
```

星星不允许改变

```
    <RatingBar android:layout_width="wrap_content"
               android:numStars="8"
               android:rating="4"
               android:stepSize="1"
               android:isIndicator="true"
               android:layout_height="wrap_content"/>
```

星星的属性

```
        RatingBar r = findViewById(R.id.ratings);
        //获取星星
        String star = String.valueOf(r.getRating());
        //每次可以改变几个星星
        String stepStar = String.valueOf(r.getStepSize());
        //进度
        String progress = String.valueOf(r.getNumStars());
```

## 图像管理器

图像显示

```
    <ImageView android:layout_width="wrap_content"
               android:src="@mipmap/ic_launcher"
               android:layout_height="wrap_content"/>
```

指定大小

```
    <ImageView android:layout_width="100dp"
               android:src="@mipmap/ic_launcher"
               android:layout_height="100dp"/>
```

指定缩放

```

```

最大宽度和最大高度，在使用一下adjustViewBounds=true

蒙上颜色

```
    <ImageView android:layout_width="160dp"
                android:src="@mipmap/ic_launcher"
               android:tint="#aa777777"
               android:layout_height="100dp"/>
```

## 图像切换





## Activity

运行状态：可以先进行操作

暂停操作：可以看见，但是不可以操作

停止状态：退出之后

销毁强制停止

#### 生命周期

创建----开始----XX---运行-----暂停---销毁

创建Activity，继承一个Activity，重写回调方法



配置Activity，在xml中进行配置，也可以设置入口。

```
<intent-filter>
	<action android:name="android.intent.action.MAIN></action>//作为响应的名称的
	<category android:name="android.intent.category.LAUNCHER"></category>//在什么情况下执行的
</intent-filter>
```

通过startActivity



finsh（）再相应的事件中调用即可

Activity刷新，使用onCreate（null）；

---------

关闭页面fiansh方法，使用之后就会将当前的关闭，然后打开另一个 。





## 多个Activity的使用

#### 参数传递



Bundle进行数据传输，使用Bundle存储的是一个一个的键值对。

将数据通过putXXX()方法保存到Bundle中，然后通过outExtras传递到Intent中的。启动另一个Activity。

```
创建一个Intent，设置本activity和目标Activity,然后创建bundle,将数据保存到bundle中，然后再讲数据放入Intent中。
```

获取参数

```
Intent intent = getIntent();
Bundle bundle = new Bundle();
bundle.getString("XX");
```



#### 调用Activity并返回结果

startActivity可以启动另一个activity，我们需要一个返回结果，那么我们使用startActivityForResult（）,可以启动一个activity，等一个activity关闭之后，就会将结果返回来。

调用格式

```
startActivityForResult(Intent intent,int requestCode)
一个是我们启动的intent，还有一个是返回的码，标识来源
Intent intent = new Intent(MainActivity.this,DetailActivity.class);  Intent对象，启动一个新的Activity
startActivityResult(intent,0x007);
```

目标activity，获取Intent，然后设置参数，返回

```
Intent intent = new Intent();
Bundle bundle = new Bundle();
bundle.putInt("key1",1);
intent.putExtras(bundle);
setResult(0x007，intent);一般设置相同
finsh();
```

## Fragment

一个行为或者是一部分的页面，通过Fragment进行页面之间的切换。他需要嵌入到一个activity中，它的生命周期收到所在的生命周期的影响。



创建Fragment，继承Fragment.

```
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    
	<TextView 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="XXXXXXXXXX"/>
</LinearLayout>

```

java代码

```
public class MyFragment extends Fragment{
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		View view = inflater.inflate(R.layout.activity_fragment, container);
		return view;
	}

}
```

在Activity中使用Fragment

在xml中引入

```

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />
	<fragment 
	    android:layout_width="wrap_content"
	    android:layout_height="match_parent"
	    android:name="com.example.listfragment.MyFragment"
	    android:id="@+id/list"
	    android:layout_weight="1"/>
	<fragment 
	    android:layout_width="wrap_content"
	    android:layout_height="match_parent"
	    android:name="com.example.listfragment.DetailFragment"
	    android:id="@+id/detail"
	    android:layout_weight="2"/>
```









运行时添加

(1)在代码中加入(不成功，不知道为什么)

```
		DetailFragment detailFragment = new DetailFragment();
		FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
		
		fragmentTransaction.add(android.R.id.content, detailFragment);
		fragmentTransaction.commit();
```

(2)





## intent

意图，Activity Service Broadcast Receiver它们之间通信使用Intent.

开启activity

开启Service

发生广播



#### 对象属性

- 组件名称 component对象  |应用包名  类名

```java
Component component = new Component(包名，包名.列名);
intent.setComponent(component);
startActivity(intent);  
页面跳转
```

- Action和Data

```
Action动作  data，数据
```

Action常量,比如打电话等

data数据url等，数据规格

案例：

​	图片按钮

​	获取图片按钮

```
Intent intent = new Intent();
ImageView s = (ImageView)v;
switch(v.getId()){
    case R.id.XX：
    	intent.setAction(intent.ACTION_DIAL);
    	intent.setData(Uri.parse("tel:233223"));
    	startActivity(intent);
}
```



- Action和Category属性

  案例

  ```
  执行返回系统桌面
  Intent intent = new Intent();
  intent.setAction(intent.ACTION_MAIN);
  intent.setCategory(intent.CATEGORY_HOME);
  ```

  

- Extras：附加数据

  多个activity中作为数据交换

- Flags：安卓程序如何启动另一个activity

  我们打开一个应用程序，我们返回桌面，下一次我们在打开的时候，就会去刚才打开的页面，我们可以设置让其从开始启动。

  ```
  Intent intent = new Intent(A,B);
  intent.setFlags(intent.FLAG_ACTIVITY_NO_HISTORY);
  startActivity(intent);
  ```

  

- Intent种类：显示和隐式

  隐式一般需要action    category   data

  隐式一般是不同应用程序之间的

- 过滤器







--------------------



---------------

### bug

- DDMS工具
- 输出信息
- 程序调试





------------

事件和大纲

事件处理   物理按键   触摸事件`



基于监听   基于模型  事件源

基于回调，某一个事件发生时，重现哪一个方法

```
@Override
	public boolean onTouchEvent(MotionEvent event) {
		Toast.makeText(MainActivity.this, "触摸", Toast.LENGTH_SHORT).show();
		return super.onTouchEvent(event);
	}
	
	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		Toast.makeText(MainActivity.this, "按键按下", Toast.LENGTH_SHORT).show();
		return super.onKeyDown(keyCode, event);
	}
	
	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) {
		Toast.makeText(MainActivity.this, "按键弹起", Toast.LENGTH_SHORT).show();
		return super.onKeyUp(keyCode, event);
	}
```

按键按下 按下 弹起 长按





## 触摸事件







## 单击事件和触摸事件

点击屏幕会出现单机和触摸事件，先执行触摸事件，如果没有消费，然后在处理单机事件。返回一个true就代表消费了。





## 手势检测

GestureDetector手势检测

GestureDetector.OnGestureListener

---------

onDown:按下    onFling：拖过    onLongPress:长托   onScroll：  onShowPress   onSingleTapUp：轻击





## 资源 

字符串  颜色   尺寸资源    布局资源   数组资源   图像资源  主题资源   菜单资源  国际化



#### 字符串

定义资源 <String>中定义    使用资源，可以是xml,也可以是java文件

- 定义资源

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">androidres</string>
    <string name="hello_world">Hello world!</string>
    <string name="action_settings">Settings</string>
</resources>
```

- 使用资源

  xml

```
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />

```

​	java中设置

```
TextView textView = (TextView)findViewById(R.id.text);
textView.setText(getResources().getString(R.string.app_name));
```



#### 颜色资源

透明度+红绿蓝

定义颜色资源

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorred">#ff0000</color>
</resources>
```

使用颜色资源

```
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@color/colorred"
        android:text="@string/hello_world" />
```

```
		TextView textView = (TextView)findViewById(R.id.textview);
		textView.setTextColor(getResources().getColor(R.color.colorred));
```

## 尺寸资源

dp:独立像素，不同屏不一样，一般使用dp

sp：设置字体大小的，可以根据手机首选进行缩放

一般步骤：创建资源文件    使用资源文件  一般是在dimen中定义的 

- 创建

```
<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
</resources>
```

- 使用

```
    <TextView
        android:layout_width="wrap_content"
        android:textSize="@dimen/activity_horizontal_margin"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />
```

```
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		TextView textView = (TextView)findViewById(R.id.textview);
		textView.setTextSize(R.dimen.activity_vertical_margin);
	}
```

## 布局资源

布局资源引用一个布局资源

<include layout="R.layout.XXX">



## 数组资源

定义资源数组文件

- 尺寸资源数组

  ```
  <array></array>
  <integer-array></integer-array>
  <string-array>
  ```

   创建

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string-array name="liststring">
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	    <item>XXX</item>
	    
	</string-array>    
</resources>
```

使用

```
	<ListView 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:entries="@array/liststring">
```



- 数字资源数组 
- 字符串资源数组



## 9.png资源

制作资源，使用资源



## stateListDrawable



在draw中定义，

失去焦点和获得焦点





## 样式



## 菜单资源文件







## Action Bar

标题上容易操作的部分，比如logo，按钮，导航等

#### 显示和隐藏Action Bar

- 怎么添加Action Bar

  ```
          <activity android:name=".MainActivity"
          android:theme="@style/Theme.AppCompat.NoActionBar">
              <intent-filter>
                  <action android:name="android.intent.action.MAIN"/>
  
                  <category android:name="android.intent.category.LAUNCHER"/>
              </intent-filter>
          </activity>
  ```

  更改主题

- 通过java代码

  显示和隐藏ActionBar

  ````
          final ActionBar actionBar = getSupportActionBar();
          Button button1 = findViewById(R.id.btn1);
          Button button2 = findViewById(R.id.btn2);
          button1.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View view) {
                  actionBar.hide();
              }
          });
          button2.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View view) {
                  actionBar.show();
              }
          });
  ````

  

- Action Item

  调用菜单文件

  在onCreateOptionsMenu()方法中加入菜单资源文件

  创建菜单

  ```
  <?xml version="1.0" encoding="utf-8"?>
  <menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto">
      <item
              android:title="XXXX"
              android:id="@+id/title"
              android:icon="@drawable/ic_launcher_background"
              app:showAsAction="always">
      </item>
      <item
              android:title="XXXX"
              android:id="@+id/title333"
              android:icon="@drawable/ic_launcher_background"
              app:showAsAction="ifRoom">
      </item>
      <item
              android:title="XXXX"
              android:id="@+id/title1"
              android:icon="@drawable/ic_launcher_background"
              app:showAsAction="ifRoom">
      </item>
      <item
              android:title="XXXX"
              android:id="@+id/title2"
              android:icon="@drawable/ic_launcher_background"
              app:showAsAction="ifRoom">
      </item>
  
  </menu>
  ```

  always:一直显示

  ifRoom:有空间就显示

  never:从不显示

  withText:显示图标，显示文本

  ## actionView

两种实现方式





## Action bar和tab

(1)使用Tab设置导航

（2）添加多个Tab标签







## 层叠是导航

点击朋友圈到达朋友圈页面，点击返回按钮进行返回

判断父Activity是否为空，不为null设置导航图标显示

getSupportActionBar().setDisplayHomeAsUpEndabled(true);显示返回图标

配置父在xml中

```
<meta-data
   name="android.support.PARENT_ACTIVIVTY"
   value="返回之前的activity"></meta-data>
```

## 消息通知和广播

Toast

```
创建Toast 对象
makeText()

指定样式 

show
```



AlertDialog

Notification

BroadCastReceiver





## 画图

画图有画笔和画布，画笔有颜色，粗细，透明度，填充样式等。画布可以改变颜色的尺寸。

实现方法：

​	创一个继承View的类，实现onDraw的方法，然后将其添加到Activity中。





## 多媒体

#### 音频播放 

MediaPlayer支持的格式有：mp3、ogg、3gb、wav格式

它是安卓提供播放视频或者音频文件件或者流的一个类。

- 步骤

  - 创建一个MediaPlayer

  - 装载一个音频文件

    - 可以根据资源文件来创建
    - 使用url来播放

  - 装载音频

    - 除了上面的方法外，还有一个是无惨构造     适用于连续播放多个视频的情况。

      通过setDataSource  使用prepare真正的装载。

- 缺点

  - 延迟时间长，真有资源多
  - 不支持同时播放多个音频

#### SoundPool

只可以播放多小的音频，音效池

- 步骤：
  - 创建对象
  - 加载音频
  - 播放音频







## SqLite

- 占用资源少
- 运行效率高
- 安全可靠
- 可移植性强



使用步骤：

​	cmd中



### Content Provider

使用基于数据模型的简单表格来提供其中的数据。



URL和uri

URL：协议固定，域名固定，网站资源（动态）,统一资源的唯一定位符 

uri：统一资源标识符



步骤:
继承ContentProvider类

声明ContentProvider  在androidMainfest.xml中定义

使用contentProvider执行添加删除更新